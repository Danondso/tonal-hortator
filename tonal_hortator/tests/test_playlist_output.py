#!/usr/bin/env python3
"""
Tests for playlist output functionality
"""

import os
import tempfile
import unittest
from unittest.mock import Mock, patch, mock_open
from datetime import datetime

from tonal_hortator.core.playlist_output import PlaylistOutput


class TestPlaylistOutput(unittest.TestCase):
    """Test playlist output functionality"""

    def setUp(self):
        """Set up test fixtures"""
        self.output = PlaylistOutput()
        self.sample_tracks = [
            {
                "artist": "Queen",
                "name": "Bohemian Rhapsody",
                "album": "A Night at the Opera",
                "duration_ms": 354000,
                "similarity_score": 0.85,
                "location": "file:///Users/test/Music/Queen/Bohemian%20Rhapsody.mp3",
            },
            {
                "artist": "Led Zeppelin",
                "name": "Stairway to Heaven",
                "album": "Led Zeppelin IV",
                "duration_ms": 482000,
                "similarity_score": 0.78,
                "location": "file:///Users/test/Music/Led%20Zeppelin/Stairway%20to%20Heaven.mp3",
            },
            {
                "artist": "The Beatles",
                "name": "Hey Jude",
                "album": "The Beatles 1967-1970",
                "duration_ms": 425000,
                "similarity_score": 0.72,
                "location": "",
            },
        ]

    def test_save_playlist_m3u_success(self):
        """Test successful M3U playlist creation"""
        with tempfile.TemporaryDirectory() as temp_dir:
            query = "Classic Rock Songs"
            filepath = self.output.save_playlist_m3u(self.sample_tracks, query, temp_dir)

            # Check file was created
            self.assertTrue(os.path.exists(filepath))
            self.assertTrue(filepath.endswith(".m3u"))

            # Check file contents
            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()

            # Check M3U header
            self.assertIn("#EXTM3U", content)
            self.assertIn("Generated by Tonal Hortator (Local)", content)
            self.assertIn(f"Query: {query}", content)
            self.assertIn("Tracks: 3", content)

            # Check track entries
            self.assertIn("#EXTINF:354,Queen - Bohemian Rhapsody", content)
            self.assertIn("#EXTINF:482,Led Zeppelin - Stairway to Heaven", content)
            self.assertIn("#EXTINF:425,The Beatles - Hey Jude", content)

            # Check file paths
            self.assertIn("/Users/test/Music/Queen/Bohemian Rhapsody.mp3", content)
            self.assertIn("/Users/test/Music/Led Zeppelin/Stairway to Heaven.mp3", content)

            # Check metadata
            self.assertIn("Album: A Night at the Opera", content)
            self.assertIn("Similarity: 0.850", content)

    def test_save_playlist_m3u_with_special_characters(self):
        """Test saving playlist with special characters in query"""
        tracks = [
            {
                "name": "Test Song",
                "artist": "Test Artist",
                "location": "/path/to/song.mp3",
            }
        ]

        with tempfile.TemporaryDirectory() as temp_dir:
            self.output.output_dir = temp_dir
            filepath = self.output.save_playlist_m3u(
                tracks, "Rock & Roll / Heavy Metal (90s)"
            )

            # Should create a valid filename without problematic characters
            self.assertIsNotNone(filepath)
            self.assertTrue(os.path.exists(filepath))
            
            # Check that the filename contains the sanitized query
            filename = os.path.basename(filepath)
            self.assertIn("Rock-Roll-Heavy-Metal-90s", filename)

    def test_save_playlist_m3u_long_query(self):
        """Test M3U playlist creation with very long query"""
        with tempfile.TemporaryDirectory() as temp_dir:
            long_query = "A" * 100  # Very long query
            filepath = self.output.save_playlist_m3u(self.sample_tracks, long_query, temp_dir)

            # Check filename length is limited
            filename = os.path.basename(filepath)
            self.assertLess(len(filename), 100)

    def test_save_playlist_m3u_missing_fields(self):
        """Test M3U playlist creation with missing track fields"""
        tracks_with_missing = [
            {
                "artist": "Unknown Artist",
                "name": "Unknown Track",
                "album": "Unknown Album",
                "duration_ms": 0,
                "similarity_score": 0.0,
                "location": "",
            }
        ]

        with tempfile.TemporaryDirectory() as temp_dir:
            query = "Test Query"
            filepath = self.output.save_playlist_m3u(tracks_with_missing, query, temp_dir)

            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()

            # Check default values are used
            self.assertIn("#EXTINF:0,Unknown Artist - Unknown Track", content)
            self.assertIn("Album: Unknown Album", content)
            self.assertIn("Similarity: 0.000", content)
            self.assertIn("# Missing file location for: Unknown Artist - Unknown Track", content)

    def test_save_playlist_m3u_url_encoding(self):
        """Test M3U playlist creation with URL-encoded file paths"""
        tracks_with_encoded = [
            {
                "artist": "Test Artist",
                "name": "Test Song",
                "album": "Test Album",
                "duration_ms": 180000,
                "similarity_score": 0.5,
                "location": "file:///Users/test/Music/Test%20Artist/Test%20Song%20with%20Spaces.mp3",
            }
        ]

        with tempfile.TemporaryDirectory() as temp_dir:
            query = "Test"
            filepath = self.output.save_playlist_m3u(tracks_with_encoded, query, temp_dir)

            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()

            # Check URL decoding
            self.assertIn("/Users/test/Music/Test Artist/Test Song with Spaces.mp3", content)
            self.assertNotIn("%20", content)

    def test_save_playlist_m3u_non_file_url(self):
        """Test M3U playlist creation with non-file URLs"""
        tracks_with_http = [
            {
                "artist": "Test Artist",
                "name": "Test Song",
                "album": "Test Album",
                "duration_ms": 180000,
                "similarity_score": 0.5,
                "location": "http://example.com/song.mp3",
            }
        ]

        with tempfile.TemporaryDirectory() as temp_dir:
            query = "Test"
            filepath = self.output.save_playlist_m3u(tracks_with_http, query, temp_dir)

            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()

            # Check HTTP URL is preserved
            self.assertIn("http://example.com/song.mp3", content)

    def test_save_playlist_m3u_exception_handling(self):
        """Test M3U playlist creation with file system errors"""
        with patch("os.makedirs") as mock_makedirs:
            mock_makedirs.side_effect = PermissionError("Permission denied")

            with self.assertRaises(PermissionError):
                self.output.save_playlist_m3u(self.sample_tracks, "Test", "invalid/path")

    def test_save_playlist_m3u_write_error(self):
        """Test M3U playlist creation with file write errors"""
        with tempfile.TemporaryDirectory() as temp_dir:
            # Make directory read-only
            os.chmod(temp_dir, 0o444)

            with self.assertRaises(Exception):
                self.output.save_playlist_m3u(self.sample_tracks, "Test", temp_dir)

    def test_print_playlist_summary(self):
        """Test playlist summary printing"""
        with patch("builtins.print") as mock_print:
            query = "Classic Rock"
            self.output.print_playlist_summary(self.sample_tracks, query)

            # Check summary header
            mock_print.assert_any_call("\nðŸŽµ Playlist for: 'Classic Rock'")
            mock_print.assert_any_call("ðŸ“Š 3 tracks found")
            mock_print.assert_any_call("-" * 60)

            # Check track entries
            mock_print.assert_any_call(" 1. Queen - Bohemian Rhapsody")
            mock_print.assert_any_call("    Album: A Night at the Opera")
            mock_print.assert_any_call("    Similarity: 0.850")

            mock_print.assert_any_call(" 2. Led Zeppelin - Stairway to Heaven")
            mock_print.assert_any_call("    Album: Led Zeppelin IV")
            mock_print.assert_any_call("    Similarity: 0.780")

            mock_print.assert_any_call(" 3. The Beatles - Hey Jude")
            mock_print.assert_any_call("    Album: The Beatles 1967-1970")
            mock_print.assert_any_call("    Similarity: 0.720")

            # Check average similarity
            mock_print.assert_any_call("ðŸ“ˆ Average similarity: 0.783")

    def test_print_playlist_summary_empty_tracks(self):
        """Test playlist summary printing with empty track list"""
        with patch("builtins.print") as mock_print:
            query = "Empty Playlist"
            self.output.print_playlist_summary([], query)

            # Check summary header
            mock_print.assert_any_call("\nðŸŽµ Playlist for: 'Empty Playlist'")
            mock_print.assert_any_call("ðŸ“Š 0 tracks found")
            mock_print.assert_any_call("-" * 60)

            # Check no average similarity is printed
            for call in mock_print.call_args_list:
                self.assertNotIn("Average similarity", str(call))

    def test_print_playlist_summary_missing_fields(self):
        """Test playlist summary printing with missing track fields"""
        tracks_with_missing = [
            {
                "artist": "Unknown",
                "name": "Unknown",
                "album": "Unknown",
                "similarity_score": 0.0,
            }
        ]

        with patch("builtins.print") as mock_print:
            query = "Test"
            self.output.print_playlist_summary(tracks_with_missing, query)

            # Check default values are used
            mock_print.assert_any_call(" 1. Unknown - Unknown")
            mock_print.assert_any_call("    Album: Unknown")
            mock_print.assert_any_call("    Similarity: 0.000")

    def test_print_playlist_summary_no_similarity_scores(self):
        """Test playlist summary printing with tracks missing similarity scores"""
        tracks_no_similarity = [
            {
                "artist": "Test Artist",
                "name": "Test Song",
                "album": "Test Album",
            }
        ]

        with patch("builtins.print") as mock_print:
            query = "Test"
            self.output.print_playlist_summary(tracks_no_similarity, query)

            # Check default similarity is used
            mock_print.assert_any_call("    Similarity: 0.000")

    def test_save_playlist_m3u_default_output_dir(self):
        """Test M3U playlist creation with default output directory"""
        with patch("os.makedirs") as mock_makedirs:
            with patch("builtins.open", mock_open()) as mock_file:
                query = "Test Query"
                filepath = self.output.save_playlist_m3u(self.sample_tracks, query)

                # Check default directory is used
                mock_makedirs.assert_called_with("playlists", exist_ok=True)
                self.assertIn("playlists", filepath)

    def test_save_playlist_m3u_timestamp_format(self):
        """Test M3U playlist creation timestamp format"""
        with tempfile.TemporaryDirectory() as temp_dir:
            query = "Test"
            filepath = self.output.save_playlist_m3u(self.sample_tracks, query, temp_dir)

            # Check timestamp format in filename
            filename = os.path.basename(filepath)
            self.assertRegex(filename, r"playlist_\d{8}_\d{6}_Test\.m3u")

            # Check timestamp format in file content
            with open(filepath, "r", encoding="utf-8") as f:
                content = f.read()
                self.assertRegex(content, r"Generated: \d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}")


if __name__ == "__main__":
    unittest.main() 